17일차(컬렉션2 구조 및 작성법,제너릭 개요 및 작성법)

조건1) 입력받은 문자열을 역순으로 출력하는 프로그램을 작성하시오.
       (ReverseTest.java)로 저장할것
조건2) Scanner 클래스를 BufferedReader클래스로 변경해서 프로그램을 작성하시오.
조건3) BuferedReader클래스 객체를 얻어오는 setBuffer(),getBuffer()를 작성해서 구현하시오.
조건4) 적절한 예외처리를 구현해서 작성하시오.

<실행결과>
문자열을 입력하세요?
             Aaaa
             aaaA

=======================================================================
  스택->한쪽은 막혀있고 한쪽은 open
  큐-->양쪽이 다 open
  배열->기차모양처럼 한쪽으로 쭉 늘여뜨린 구조(리스트)
  사물함->특정키값를 이용해서 값을 저장

 .....>클래스로만 만들어져 있으며 있으면 =>메서드가 통일감X

 인터페이스 작성(공통 메서드)->     Collection

                                    데이터 저장 구조에 따라서

                                      List
                                      Set
                                      Map
           |
        상속->자식클래스

 데이터를 관리->자바의 컬렉션->구조와 상관없이 공통적으로 사용(기능)
 
 테이블의 설계->

***********************************************
 1.데이터를 저장(추가) ->insert
 2.데이터를 삭제 ->delete
 3.데이터를 수정->원하는 데이터만 수정 ->update
 4.데이터를 검색->select
*************************************************

** 데이터의 구조(저장구조)에 따른 인터페이스 분류**

1.Set  인터페이스

  ->데이터가 중복 저장이 안되며 저장 되는 순서가 없다.(ex 항아리)
  ->HashSet

**2.List  인터페이스->중복저장이 가능,저장순서가 있다(인덱스번호로 구분)
  ->Vector->ArrayList,LinkedList

**3.Map 인터페이스->표형태로 저장 (키,값)=>ex)사물함 구조
                        -=>값을 저장시 키를 부여=>키를 이용
                         ->빨리 검색된다.

   ->HashTable,HsahMap=>세션값을 저장시(web)
------------------------------------------------------------------------
  **<자료형> =>제너릭?**
------------------------------

컬렉션의 공통특성

1.객체만 저장(기본 자료형은 저장X->Wrapper 클래스를 이용 가능)
2.정적배열(크기가 정해져 있는 경우)<->동적배열(크기가 유동)
      byte b[]=new byte[3];
--------------------------------------------------------------
3.객체를 저장->형이 Object형으로 변환(어떠한 객체라도 다 저장이 가능
                                      하게 만들기위한 목적)
 --->String(O),다른 데이터 저장X

4.저장된 데이터를 꺼내올때 원래의 형으로 형변환시켜야 된다.
  ->문제발생->자료형이 문제발생(ex Type mismatch)

  
   VectorTest.java


--------------------------------------------------------------------
=><자료형(String)>=>저장할 자료형을 미리 지정하는 "제너릭"
=>VectorTest.java

  EnumTest.java

=>ArrayListTest.java=>ArrayList
=>리스트 구조내부에 배열이 저장이 된 구조

**컬렉션의 값을 검색**->클래스 마다 조금씩 차이가 있다.(암기)
                          ArrayList->get(인덱스번호)
                          Vector->elementAt(인덱스번호)
                          ,,,,

//컬렉션의 구조가 다르다 할지라도 공통으로 검색->Enumeration인터페이스
	    //인터페이스의 객체->1.메서드의 매개변수 ,** 2.메서드의 반환형 **
	    //1.Enumeration<String> eu=new Enumeration<String>();
	    Enumeration<String> eu=v.elements();
	    while(eu.hasMoreElements()) {//검색할 데이터가 들어가 있다면
	    	System.out.println(eu.nextElement());
	    }
	    //2.Iterator->도서관의 책꽂이에 들어가 있는 책을 연상
	    //                 ->책을 꺼내올때 순서중요X
	    Collection<String> c=h.values();//1.Collection객체 얻어오기
	    Iterator<String> ih=c.iterator();
	    while(ih.hasNext()) {//검색할 데이터가 들어가 있다면
	    	System.out.println(ih.next());
	    }

p614->Iterator(hasNext()->데이터저장 유무확인?,next()->꺼내와라),
           Enumeration(검색에 관련된 인터페이스)->p617
                      (hasMoreElement(),nextElement())
           데이터 저장 구조에 상관없이 공통적인 검색방법을 사용이 가능
           =>메서드의 매개변수 또는 반환형을 통해서 객체를 얻어옴
          ===================================
 컬렉션(12장)->제너릭의 정리<E>,<K,E>~
==========================
p644->HashMap,Hashtable(key,value)->사물함
p647->표형태로 저장(키를 지정해서 저장)
========================================
p670
     제너릭의 개요

컬렉션에 데이터를 저장->반드시 객체만 저장이 된다.

->String,Integer,,,,=>자동적으로 Object형으로 변환이 된다.

->String만 저장이 돼야되는데 Integer,Double을 저장해도=>에러가
    발생이 안되고 저장이 된다.

=>저장된 데이터를 꺼내올때 (String)==>문제가 발생=>유지보수 걸림
================================================================

처음부터 저장할 데이터만 따로지정=>객체생성시 클래스명<자료형>

*제너릭의 장점*

1.지정->지정된 자료형외에는 저장불가(명확하다)
  ->원하는 데이터만 저장가능

2.꺼내올때 명시적인 형변환을 할 필요가 없다.=>유지보수가 좋다

   <E>,        <K,V> =>Map계열 ,<T> =>클래스 설계할때
   element     key,value        Type

Vector<String> v=new Vector<String>();
-------------------------------------------------------------

 **제너릭의 종류(추상화와 연관)**

p674 제네릭 클래스를 작성

1.class 클래스명<T>{}->p670=>자료형이 Object인 대신사용하는 
                                               키워드 T(Type)->어떠한 자료형도
                                               다 수용해주겠다는 표시

 =====>이 클래스를 통해서 만든 객체의 자료형을 미리 지정해주는 경우
 =>ArrayList2.java
--------------------------------------------------------------------
  와일드 카드형태

 =>메서드의 매개변수 전달형태
2.p679=><?>========>WildTest.java
               <? extends Object>와 동일하다
                  자바에서 만드는 클래스는 부모는 무조건  Object이기때문에
                   ->제한이 없다.
             ----------------------------------------
              ->아직 자료형이 정해져 있지 않다=>Object
              ->전달받은 자료형으로 대신사용하겠다. String-><String>

             <String>,<Integer>,<Double>->자료형에 맞는 메서드를 작성
               =>3개를 작성->코딩양이 증가->중복된 코드도 증가
           -----------------------------------------------------------------
           =>어떠한 자료형이든 다 처리해줄 수있는 제너릭이 있다. <?>
          ------------------------------------------------------------------
           p679
          //<?> 매개변수를 전달받을때 자료형은 그때그때 마다 바뀔수 있다.
	//                                        (List<Object> list) 대용
	public static void printData(List<?>  list) {  //(ArrayList  list)
		for(Object obj:list)
			System.out.println(obj);//obj.toString()->문자로 출력
	}

                상속과 연관 이 되어 있는 경우
                
<!-- <? extends T> =>WildExtend.java로 저장 -->
 =>상속관계로 이루어진 클래스만 자료형으로 받게다는 표시                
 ? =>자식클래스, T(부모클래스)=>부모클래스 뿐만아니라 자식클래스만 임의의
자료형만 입력을 받고싶다.


